/**
 * BookStore APIs
 * BookStore APIs exposed from a Java EE back-end to an Angular front-end
 *
 * OpenAPI spec version: 1.0.0
 * Contact: wiliam334@hotmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import {Inject, Injectable, Optional} from '@angular/core';
import {Http, Headers, URLSearchParams} from '@angular/http';
import {RequestMethod, RequestOptions, RequestOptionsArgs} from '@angular/http';
import {Response, ResponseContentType} from '@angular/http';

import {Observable} from 'rxjs/Observable';
import '../rxjs-operators';

import {Book} from '../model/book';

import {BASE_PATH, COLLECTION_FORMATS} from '../variables';
import {Configuration} from '../configuration';

/**
 * Service class to handle book business logic.
 */
@Injectable()
export class BookService {

  protected basePath = 'http://localhost:8080/bookstore-back/api';
  public defaultHeaders: Headers = new Headers();
  public configuration: Configuration = new Configuration();

  constructor(protected http: Http, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
   // add Allow headers
    this.defaultHeaders.append('Access-Control-Allow-Origin', 'http://localhost:8080');
    this.defaultHeaders.append('Access-Control-Allow-Methods', '"GET, PUT, POST');

    if (basePath) {
      this.basePath = basePath;
    }
    if (configuration) {
      this.configuration = configuration;
    }
  }

  /**
   *
   * Extends object by coping non-existing properties.
   * @param objA object to be extended
   * @param objB source object
   */
  private extendObj<T1, T2>(objA: T1, objB: T2) {
    for (let key in objB) {
      if (objB.hasOwnProperty(key)) {
        (objA as any)[key] = (objB as any)[key];
      }
    }
    return <T1 & T2>objA;
  }

  /**
   * @param consumes string[] mime-types
   * @return true: consumes contains 'multipart/form-data', false: otherwise
   */
  private canConsumeForm(consumes: string[]): boolean {
    const form = 'multipart/form-data';
    for (let consume of consumes) {
      if (form === consume) {
        return true;
      }
    }
    return false;
  }

  /**
   *
   * @summary Returns the number of books
   */
  public countBooks(extraHttpRequestParams?: any): Observable<number> {
    return this.countBooksWithHttpInfo(extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Creates a book given a JSon Book representation
   */
  public createBook(body: Book, extraHttpRequestParams?: any): Observable<{}> {
    return this.createBookWithHttpInfo(body, extraHttpRequestParams)
      .map((response: Response) => {
        switch (response.status) {
          case 204 :
            return undefined;
          case 201 :
            return response;
          default :
            return response.json();
        }
      });
  }

  /**
   *
   * @summary Update the book for given id
   * @param id
   */
  public updateBook(id: number, body: Book, extraHttpRequestParams?: any): Observable<Book> {
    return this.updateBookWithHttpInfo(id, body, extraHttpRequestParams)
      .map((response: Response) => {
        switch (response.status) {
          case 204 :
            return undefined;
          case 201 :
            return response;
          case 200 :
            return response;
          default :
            return response.json();
        }
      });
  }

  /**
   *
   * @summary Deletes a book given an id
   * @param id
   */
  public deleteBook(id: number, extraHttpRequestParams?: any): Observable<{}> {
    return this.deleteBookWithHttpInfo(id, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Returns a book for given id
   * @param id
   */
  public getBook(id: number, extraHttpRequestParams?: any): Observable<Book> {
    return this.getBookWithHttpInfo(id, extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   *
   * @summary Returns all the books
   */
  public getBooks(extraHttpRequestParams?: any): Observable<Array<Book>> {
    return this.getBooksWithHttpInfo(extraHttpRequestParams)
      .map((response: Response) => {
        if (response.status === 204) {
          return undefined;
        } else {
          return response.json() || {};
        }
      });
  }

  /**
   * Returns the number of books
   *
   */
  public countBooksWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/books/count';

    let queryParameters = new URLSearchParams();
    let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


    // to determine the Accept header
    let produces: string[] = [
      'text/plain'
    ];


    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials:this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Creates a book given a JSon Book representation
   *
   */
  public createBookWithHttpInfo(body: Book, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/books';

    let queryParameters = new URLSearchParams();
    let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error('Required parameter body was null or undefined when calling createBook.');
    }

    // to determine the Accept header
    let produces: string[] = [];

    headers.set('Content-Type', 'application/json');

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Post,
      headers: headers,
      body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Update the book for given id
   * @param id
   */
  public updateBookWithHttpInfo(id: number, body: Book, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/books/${id}'
      .replace('${' + 'id' + '}', String(id));

    let queryParameters = new URLSearchParams();
    let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling updateBook.');
    }
    // to determine the Content-Type header
    let consumes: string[] = [
      'application/json'
    ];

    // to determine the Accept header
    let produces: string[] = [
      'application/json'
    ];

    headers.set('Content-Type', 'application/json');

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Put,
      headers: headers,
      body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }
    return this.http.request(path, requestOptions);
  }

  /**
   * Deletes a book given an id
   *
   * @param id
   */
  public deleteBookWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/books/${id}'
      .replace('${' + 'id' + '}', String(id));

    let queryParameters = new URLSearchParams();
    let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling deleteBook.');
    }
    // to determine the Content-Type header
    let consumes: string[] = [];

    // to determine the Accept header
    let produces: string[] = [];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Delete,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Returns a book for given id
   *
   * @param id
   */
  public getBookWithHttpInfo(id: number, extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/books/${id}'
      .replace('${' + 'id' + '}', String(id));

    let queryParameters = new URLSearchParams();
    let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // verify required parameter 'id' is not null or undefined
    if (id === null || id === undefined) {
      throw new Error('Required parameter id was null or undefined when calling getBook.');
    }
    // to determine the Content-Type header
    let consumes: string[] = [];

    // to determine the Accept header
    let produces: string[] = [
      'application/json'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

  /**
   * Returns all the books
   *
   */
  public getBooksWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
    const path = this.basePath + '/books';

    let queryParameters = new URLSearchParams();
    let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
    // to determine the Content-Type header
    let consumes: string[] = [];

    // to determine the Accept header
    let produces: string[] = [
      'application/json'
    ];

    let requestOptions: RequestOptionsArgs = new RequestOptions({
      method: RequestMethod.Get,
      headers: headers,
      search: queryParameters,
      withCredentials: this.configuration.withCredentials
    });
    // https://github.com/swagger-api/swagger-codegen/issues/4037
    if (extraHttpRequestParams) {
      requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
    }

    return this.http.request(path, requestOptions);
  }

}
